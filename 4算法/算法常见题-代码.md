## 算法

### 两个有序数组中位数*

[4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

> 给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。
>
> 算法的时间复杂度应该为 `O(log (m+n))` 。
>
> hard

- 思路

  ```
  
          计算两个有序数组的中位数，转换成计算两个数组的第k小的数
  
          要干嘛：找中位数，其实就是找下标，第k小的数
  
          暴力思路：双指针，小的值就向后移动（一定不是答案）
  
          核心结论：两个升序数组找第k大的数，一定会有个数组的前k/2个会被丢弃，满足条件就二分丢弃
  
          二分思路：第k小的数，每次选取两个数组的k/2个元素，判A[k/2]和B[k/2]大小关系，小的那一批，就一定不是答案所以要去除  
          
          参考题解：https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/
  
          注意点： 1.考虑某一个数组为空的情形
                  2.怎么表示一个数组(长度n)的两个中位数 left = (n+1)/2 right = (n+2)/2
                  3.递归的时候，传入左下标start，虽然要判断的是右下标（变量i,j），end表示数组的末尾下标值（常量）
                  4.递归的时候，固定nums1长度短
                  5.数组起点已经越界的判断：计算len，len==0?
                  6.递归出口：1.len =0 2.k=1表示找到
                  7.计算start1,start2此时的右端点时，要进行min(len,k/2)，保证右端点不越界
  
  ```

- 注释代码

```
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n1 = nums1.length, n2 = nums2.length;
        int k1 = (n1+n2+1)/2;//左中位数
        int k2 = (n1+n2+2)/2;//右中位数
        

        int val1 = getKth(nums1,n1-1,0,nums2,n2-1,0,k1);
        int val2 = getKth(nums1,n1-1,0,nums2,n2-1,0,k2);

        return (val1+val2) * 0.5;
    } 

    // 计算两个有序数组的第k小的数
    // end1,end2表示两个数组的最后一个元素的下标
    // start1,start2表示两个数组下一轮开始的下标
    int getKth(int[] nums1,int end1,int start1,int[] nums2,int end2,int start2,int k){
        //计算当前start1开始距离nums1结尾的元素个数（用来判断是否有数组变成空了）
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //保证nums1短
        if (len1 > len2) return getKth(nums2,end2,start2,nums1,end1,start1,k);
        //此时数组起点已经越界了，答案一定在Nums2[start2]开始的第k个中
        if (len1==0) return nums2[start2+k-1];
        
        ///如果找最小的，就是直接返回
        if (k==1) return Math.min(nums1[start1],nums2[start2]);

        //计算两个尾节点，为了防止划分k/2时越界所以取min
        int i = start1 + Math.min(len1,k/2) - 1;
        int j = start2 + Math.min(len2,k/2) - 1;
        
        //小的被淘汰
        if (nums1[i] < nums2[j]){
            return getKth(nums1,end1,i+1,nums2,end2,start2,k-(i-start1+1));
        }else{
            return getKth(nums1,end1,start1,nums2,end2,j+1,k-(j-start2+1));
        }
    }
}
```

- 简便代码

  为了方便递归传参，直接在外面定义全局数组，和end

```
class Solution {
    int[] nums1,nums2;
    int end1,end2;

    public double findMedianSortedArrays(int[] a, int[] b) {
        nums1 = a;
        nums2 = b;
        
        int n1 = nums1.length;
        int n2 = nums2.length;

        end1 = n1-1;
        end2 = n2-1;
        int k1 = (n1+n2+1)/2;
        int k2 = (n1+n2+2)/2;

        return 0.5 * (getKth(0,0,k1) + getKth(0,0,k2));
    }

    int getKth(int start1,int start2,int k){
        int len1 = end1 - start1+1;
        int len2 = end2 - start2+1;
        if (len1==0) return nums2[start2+k-1];
        if (len2==0) return nums1[start1+k-1];
        if (k==1) return Math.min(nums1[start1],nums2[start2]);
        int i = start1 + Math.min(k/2,len1) - 1;
        int j = start2 + Math.min(k/2,len2) - 1;
        
        if (nums1[i] < nums2[j])
            return getKth(i+1,start2,k-(i-start1+1));
        else return getKth(start1,j+1,k-(j-start2+1));
        
    }
}
```





### 正则表达式匹配*

[10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

> 给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。
>
> - `'.'` 匹配任意单个字符
> - `'*'` 匹配零个或多个前面的那一个元素
>
> 所谓匹配，是要涵盖 **整个** 字符串 `s` 的，而不是部分字符串。
>
> hard

```
class Solution {
    /*
        动态规划 O(n*m)

        状态表示：dp[i][j]表示s[1~i]和p[1~j]两个子串是否匹配

        划分思路：考虑p[j]选什么

        状态计算：
                1.如果p[j]是字母
                    1.1 如果p[j]==s[i] : dp[i-1][j-1]
                    1.2 如果p[j]!=s[i] : false
                2.如果p[j]是. : dp[i-1][j-1]
                3.如果p[j]是* ,那么考虑p[j-1]怎么取值？
                    3.1如果s[i]!=p[j-1]：dp[i][j-2]
                    3.2如果s[i]==p[j-1],有两种情况，考虑*到底给不给s[i]用？
                        给，之前也会用很多次：dp[i-1][j]
                        不给，留着以后用：dp[i][j-2]
        
        错误点：
                在3.2的地方，s[i]==p[j-1]太过于粗糙，没有考虑.的情况
                会导致这种情况失效：s = "ab", p = ".*"
                解决方法：定义Match函数统一匹配
     */
    char[] s,p;
    public boolean isMatch(String ss, String pp) {
        int n = ss.length(),m = pp.length();
        //本题数组下标从1开始
        s = (" "+ss).toCharArray();
        p = (" "+pp).toCharArray();
        boolean[][] dp = new boolean[n+1][m+1];
        
        //空串满足匹配
        dp[0][0] = true;
        //s的空前缀匹配p的正则前缀，比如s=ab,p=b*ab,b*就要被抛弃，也就是s[0][2]=true
        for(int j=1;j<=m;j++){
            if (p[j]=='*')
                dp[0][j] = dp[0][j-2];
        }
        
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                //如果s[i]和p[j]相等或者p[j]=.
                if(match(i,j))
                    dp[i][j] = dp[i-1][j-1];
                //如果s[i]和p[j]不相等并且p[j]!='*',那么正则匹配失效
                else if (p[j] != '*')
                    dp[i][j] = false;
                //如果p[j]='*'，
                else{
                    //判断p[j-1](*前面的字符)是否匹配
                    if(match(i,j-1))
                        dp[i][j] = dp[i-1][j] || dp[i][j-2];//如果匹配这个*表达式，分两种情况
                        // 用*匹配还是不用
                        // 情况1：用，前面可能还有，所以dp[i-1][j]
                        // 情况2：不用，留着以后用，dp[i][j-2]
                    // 不匹配，这个*就匹配0次
                    else dp[i][j] = dp[i][j-2];
                }
            }
        }
        return dp[n][m];
    }

    //判断s[i]与p[j]是否匹配
    boolean match(int i,int j){
        if (s[i]==p[j]) return true;
        if (p[j]=='.') return true;
        return false;
    }
}
```



### 快速排序

```
void quick_sort(int[] nums,int l,int r){
	if(l>=r) return;
	int pow = nums[l];
	int i = l-1, j = r+1;
	while (i<j){
		while(nums[++i]<pow)
		while(nums[--j]>pow)
		if(i<j){
			swap(i,j)
		}
	}
	quick_sort(nums,l,i);
	quick_sort(nums,i+1,r);

}
```

### 归并排序

```
		static int[] tmp = new int[N];//临时数组
        static void mergeSort(int[] a,int l,int r) {
            if(l>=r) return;
            int mid = l + r>>1;
            mergeSort(a, l, mid);
            mergeSort(a, mid+1, r);
            int k=0;//临时数组tmp的下标计数
            int i=l,j=mid+1;
            while(i<=mid && j<=r) {
                if(a[i]<=a[j]) tmp[k++] = a[i++];
                else tmp[k++] = a[j++];
            }
            while(i<=mid) tmp[k++] = a[i++];
            while(j<=r) tmp[k++] = a[j++];

            for(i=l,j=0;i<=r && j<k;i++,j++) {
                a[i] = tmp[j];
            }
        }
```



## 数据结构

### 反转链表

递归、迭代



### 链表中点



### 有限制反转链表



### 二叉树反转链表



## 架构设计

### 设计阻塞队列

ReentrantLock、阻塞（可以直接用ArrayBlockingQueue）

```
package algobi;

import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/*
    2024/7/31 23:48
    @author ZW
    Project Name:aJavaOJ
     
*/
public class MyBlockingQueue {

    Queue<Integer> q =  new LinkedList<>();
    int capacity;
    ReentrantLock lock = new ReentrantLock();
    Condition notFull = lock.newCondition();
    Condition notEmpty = lock.newCondition();
    
    public MyBlockingQueue(int capacity) {
        this.capacity = capacity;
    }
    
    void put(int val) throws InterruptedException {
        try {
            lock.lockInterruptibly();
            while(size()==capacity)
                notFull.await();
            q.add(val);
            notEmpty.signalAll();
    
        }finally {
            lock.unlock();
        }
    }
    
    int take() throws InterruptedException{
        try {
            lock.lockInterruptibly();
            while (size()==0)
                notEmpty.await();
            int res = q.poll();
            notFull.signalAll();
            return res;
        }finally {
            lock.unlock();
        }
    }
    
    int size() {
        return q.size();
    }
}

```

