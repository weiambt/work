# 场景题

https://blog.csdn.net/qq_33445788/article/details/140679259?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-3-140679259-blog-38710051.235%5Ev43%5Econtrol&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-3-140679259-blog-38710051.235%5Ev43%5Econtrol&utm_relevant_index=6

### 40亿个32位的数，只给1G内存如何去重？

- 正常用哈希存

  每个元素是一个int，4字节，有40亿个，就是4 * 4e9 = 2^34 字节 =16G左右

- Bitmap

  使用这个的好处是，是一个二进制数组，每一个位置只有0或者1，假设有值域n个数，那就开n个大小的空间，因为是32位数。也就是， 4e9个数字，共占用4e9位 = 4e9/8 = 2e7字节= 2^29B = 512M

- 布隆过滤器

  有k个哈希函数，假设哈希函数彼此独立，对于同一个输入(以字符串表示的URL)，经过k个哈希函数的计算结果也是相互独立。对计算的每一个结果Mod m，将bit array上对应的位置置1，如下：

  一个输入对象会将bitmap某些位置涂黑，处理完所有输入对象，会将bitmap相当多位置涂黑，至此，布隆过滤器生成完毕，代表之前所有输入对象的集合。

> - **BitMap位图的优势和不足**
>   位图（BitMap），基本思想就是用一个bit来标记元素，bit是计算机中最小的单位，也就是我们常说的计算机中的0和1，这种就是用一个位来表示的。
>
>   BitMap位图的主要优势在于它可以非常高效地进行集合运算。具体来说，如果我们需要对一个集合进行多次交集、并集、差集等操作，使用 BitMap 可以将这些操作的时间复杂度降低到 O(1) 级别，而传统的集合实现则需要 O(n) 的时间复杂度，其中 n 是集合的大小。
>
>   此外，BitMap 还可以节省存储空间。对于一个只包含 0 和 1 的集合，我们可以使用一个比特位来表示一个元素是否在集合中，这样可以将集合的存储空间降低到原来的 1/8 左右。
>
>   所以，位图最大的好处就是节省空间。
>
>   位图有很多种用途，特别适合用在去重、排序等场景中，著名的布隆过滤器就是基于位图实现的。
>
>   但是位图也有着一定的限制，那就是他只能表示0和1，无法存储其他的数字。
>
>   所以BitMap只适合这种能表示ture or false的场景。
>
>   其次，BitMap 只适用于值域比较小的集合，因为如果值域过大，BitMap 的存储空间也会过大，这时候使用布隆过滤器可能更为合适。
>
>   最后，BitMap 不支持删除操作，因为删除一个元素需要将对应的比特位设置为 0，这可能会影响到其他元素的状态。
>   ————————————————
>
>                             版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
>
> 原文链接：https://blog.csdn.net/qq_45038038/article/details/135086749

- 海量数据去重场景：布隆过滤器和位图如何选择
  布隆过滤器和位图都是常用的数据结构，但它们的应用场景和实现方式不同。

  - 布隆过滤器是一种概率型数据结构，用于判断一个元素是否存在于一个集合中。但有一定的误判概率。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。

  - 位图是一种简单的数据结构，用于表示一个二进制序列。它通过一个比特位数组来表示一个集合，其中每个比特位表示一个元素是否存在于集合中。当需要判断一个元素是否存在于集合中时，只需要检查对应的比特位是否为 1 或 0 即可。

  相比之下，布隆过滤器的空间效率更高，但存在一定的误判概率；而位图的空间效率较低，但不存在误判。因此，在实际应用中，需要根据具体的场景选择合适的数据结构。
  




### 有20亿个字节的数据, 求 交集,并集,差集

给定两个整数集合A和B，每个集合都包含20亿个不同整数，请给出快速计算A∩B的算法，算法可使用外存，但是要求占用内存不能超过4GB.

- 方法：使用Bitmap

  每个集合都用Bitmap存储，最后将两个bitmap按位与、或

- 哈希分块（最优）

  为了求两个1亿行文件的交集，我们可以使用分治和哈希的策略，将原文件根据哈希值分成若干个小文件（A有1000个，B有1000个，**因为相同元素的哈希值一定相同，所以一定会被分到同一个下标的文件**），然后分别求这些小文件的交集（A_1和B_1的交集，A_2和B_2的交集，...）。时间复杂度O（n）。

  下面是具体的步骤：

  1. 哈希值分块O（N）
  2. 每一对子文件通过哈希表求交集O（N/k * k）= O（n）,k对子文件

  

### 分布式共享session，俩个客户端同时登录同一个账号，会发生什么，存在redis中的session会发生什么?

当两个客户端同时登录同一个账号时，Redis中可能会存储两个独立的session对象。然而，为了确保系统的安全性和数据的一致性，系统需要实施适当的策略来处理这种情况。这些策略可能包括更新或删除旧的session对象、终止已登录用户的session等。同时，系统还需要注意安全性问题，如保护session ID的传输和存储等。